{"ast":null,"code":"function Astar(startNode, endNode) {\n  let openSet = [];\n  let closedSet = [];\n  let path = [];\n  let visitedNodes = [];\n  openSet.push(startNode); //gets the index with the lowest f value\n\n  while (openSet.length > 0) {\n    let leastIndex = 0;\n\n    for (let i = 0; i < openSet.length; i++) {\n      if (openSet[i].f < openSet[leastIndex].f) {\n        leastIndex = i;\n      }\n    }\n\n    let current = openSet[leastIndex];\n    visitedNodes.push(current);\n\n    if (current === endNode) {\n      let temp = current;\n      path.push(temp);\n\n      while (temp.previous) {\n        path.push(temp.previous);\n        temp = temp.previous;\n      } // console.log(path);\n\n\n      return {\n        path,\n        visitedNodes\n      }; // console.log(\"Done! Path found!\");\n    }\n\n    openSet = openSet.filter(elt => elt !== current);\n    closedSet.push(current);\n    let neighbors = current.neighbors;\n\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n\n      if (!closedSet.includes(neighbor) && !neighbor.isWall) {\n        let tempG = current.g + 1;\n        let newPath = false;\n\n        if (openSet.includes(neighbor)) {\n          if (tempG < neighbor.g) {\n            neighbor.g = tempG;\n            newPath = true;\n          }\n        } else {\n          neighbor.g = tempG;\n          newPath = true;\n          openSet.push(neighbor);\n        }\n\n        if (newPath) {\n          neighbor.h = heuristic(neighbor, endNode);\n          neighbor.f = neighbor.h + neighbor.g;\n          neighbor.previous = current;\n        }\n      }\n    }\n  }\n\n  return {\n    path,\n    visitedNodes,\n    error: \"No Path Found!\"\n  };\n}\n\n_c = Astar;\n\nfunction heuristic(a, b) {\n  return Math.abs(a.x - a.y) + Math.abs(b.x - b.y);\n}\n\nexport default Astar;\n\nvar _c;\n\n$RefreshReg$(_c, \"Astar\");","map":{"version":3,"names":["Astar","startNode","endNode","openSet","closedSet","path","visitedNodes","push","length","leastIndex","i","f","current","temp","previous","filter","elt","neighbors","neighbor","includes","isWall","tempG","g","newPath","h","heuristic","error","a","b","Math","abs","x","y"],"sources":["/Users/aqtruong/Desktop/pathfinding/algorithm-path-visualizer/src/astarAlgorithm/astar.js"],"sourcesContent":["function Astar(startNode, endNode) {\n    let openSet = [];\n    let closedSet = [];\n    let path = [];\n\n    let visitedNodes = [];\n\n\n    openSet.push(startNode);\n    //gets the index with the lowest f value\n    while (openSet.length > 0) {\n        let leastIndex = 0;\n        for (let i = 0; i < openSet.length; i++) {\n            if (openSet[i].f < openSet[leastIndex].f) {\n                leastIndex = i;\n            }\n\n        }\n        let current = openSet[leastIndex];\n        visitedNodes.push(current);\n        if (current === endNode) {\n            let temp = current;\n            path.push(temp);\n            while(temp.previous){\n                path.push(temp.previous);\n                temp = temp.previous;\n            }\n           // console.log(path);\n            return {path, visitedNodes};\n           // console.log(\"Done! Path found!\");\n        }\n\n        openSet = openSet.filter((elt) => elt !== current);\n        closedSet.push(current);\n\n        let neighbors = current.neighbors;\n        for (let i = 0; i < neighbors.length; i++) {\n            let neighbor = neighbors[i];\n            if (!closedSet.includes(neighbor) && !neighbor.isWall) {\n                let tempG = current.g + 1;\n                let newPath = false;\n                if (openSet.includes(neighbor)) {\n                    if (tempG < neighbor.g) {\n                        neighbor.g = tempG;\n                        newPath = true;\n                    }\n                } else {\n                    neighbor.g = tempG;\n                    newPath = true;\n                    openSet.push(neighbor);\n                }\n\n                if (newPath) {\n                    neighbor.h = heuristic(neighbor, endNode);\n                    neighbor.f = neighbor.h + neighbor.g;\n                    neighbor.previous = current;\n\n                }\n            }\n        }\n    }\n    return {path, visitedNodes, error: \"No Path Found!\"};\n}\n\nfunction heuristic(a, b) {\n    \n    return (Math.abs(a.x - a.y) + Math.abs(b.x - b.y));\n}\n\nexport default Astar;"],"mappings":"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"},"metadata":{},"sourceType":"module"}