{"ast":null,"code":"function Astar(startNode, endNode) {\n  let openSet = [];\n  let closedSet = [];\n  let path = [];\n  openSet.push(startNode); //gets the index with the lowest f value\n\n  while (openSet.length > 0) {\n    let leastIndex = 0;\n\n    for (let i = 0; i < openSet.length; i++) {\n      if (openSet[i].f < openSet[leastIndex].f) {\n        leastIndex = i;\n      }\n    }\n\n    let current = openSet[leastIndex];\n\n    if (current === endNode) {\n      let temp = current;\n      path.push(temp.previous);\n\n      while (temp.previous) {\n        path.push(temp.previous);\n        temp = temp.previous;\n      }\n\n      console.log(path);\n      return path;\n      console.log(\"Done! Path found!\");\n    }\n\n    openSet = openSet.filter(elt => elt !== current);\n    closedSet.push(current);\n    let neighbors = current.neighbors;\n\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n\n      if (!closedSet.includes(neighbor)) {\n        let tempG = current.g + 1;\n        let newPath = false;\n\n        if (openSet.includes(neighbor)) {\n          if (tempG < neighbor.g) {\n            neighbor.g = tempG;\n            newPath = true;\n          }\n        } else {\n          neighbor.g = tempG;\n          newPath = true;\n          openSet.push(neighbor);\n        }\n\n        if (newPath) {\n          neighbor.h = heuristic(neighbor, endNode);\n          neighbor.f = neighbor.h + neighbor.g;\n          neighbor.previous = current;\n        }\n      }\n    }\n  }\n}\n\n_c = Astar;\n\nfunction heuristic(a, b) {\n  let d = Math.abs(a.x - a.y) + Math.abs(b.x - b.y);\n  return d;\n}\n\nexport default Astar;\n\nvar _c;\n\n$RefreshReg$(_c, \"Astar\");","map":{"version":3,"names":["Astar","startNode","endNode","openSet","closedSet","path","push","length","leastIndex","i","f","current","temp","previous","console","log","filter","elt","neighbors","neighbor","includes","tempG","g","newPath","h","heuristic","a","b","d","Math","abs","x","y"],"sources":["/Users/aqtruong/Desktop/pathfinding/algorithm-path-visualizer/src/astarAlgorithm/astar.js"],"sourcesContent":["function Astar(startNode, endNode) {\n    let openSet = [];\n    let closedSet = [];\n    let path = [];\n\n    openSet.push(startNode);\n    //gets the index with the lowest f value\n    while (openSet.length > 0) {\n        let leastIndex = 0;\n        for (let i = 0; i < openSet.length; i++) {\n            if (openSet[i].f < openSet[leastIndex].f) {\n                leastIndex = i;\n            }\n\n        }\n        let current = openSet[leastIndex];\n        if (current === endNode) {\n            let temp = current;\n            path.push(temp.previous);\n            while(temp.previous){\n                path.push(temp.previous);\n                temp = temp.previous;\n            }\n            console.log(path);\n            return path;\n            console.log(\"Done! Path found!\");\n        }\n\n        openSet = openSet.filter((elt) => elt !== current);\n        closedSet.push(current);\n\n        let neighbors = current.neighbors;\n        for (let i = 0; i < neighbors.length; i++) {\n            let neighbor = neighbors[i];\n            if (!closedSet.includes(neighbor)) {\n                let tempG = current.g + 1;\n                let newPath = false;\n                if (openSet.includes(neighbor)) {\n                    if (tempG < neighbor.g) {\n                        neighbor.g = tempG;\n                        newPath = true;\n                    }\n                } else {\n                    neighbor.g = tempG;\n                    newPath = true;\n                    openSet.push(neighbor);\n                }\n\n                if (newPath) {\n                    neighbor.h = heuristic(neighbor, endNode);\n                    neighbor.f = neighbor.h + neighbor.g;\n                    neighbor.previous = current;\n\n                }\n            }\n        }\n    }\n}\n\nfunction heuristic(a, b) {\n    let d = Math.abs(a.x - a.y) + Math.abs(b.x - b.y);\n    return d;\n}\n\nexport default Astar;"],"mappings":"AAAA,SAASA,KAAT,CAAeC,SAAf,EAA0BC,OAA1B,EAAmC;EAC/B,IAAIC,OAAO,GAAG,EAAd;EACA,IAAIC,SAAS,GAAG,EAAhB;EACA,IAAIC,IAAI,GAAG,EAAX;EAEAF,OAAO,CAACG,IAAR,CAAaL,SAAb,EAL+B,CAM/B;;EACA,OAAOE,OAAO,CAACI,MAAR,GAAiB,CAAxB,EAA2B;IACvB,IAAIC,UAAU,GAAG,CAAjB;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,OAAO,CAACI,MAA5B,EAAoCE,CAAC,EAArC,EAAyC;MACrC,IAAIN,OAAO,CAACM,CAAD,CAAP,CAAWC,CAAX,GAAeP,OAAO,CAACK,UAAD,CAAP,CAAoBE,CAAvC,EAA0C;QACtCF,UAAU,GAAGC,CAAb;MACH;IAEJ;;IACD,IAAIE,OAAO,GAAGR,OAAO,CAACK,UAAD,CAArB;;IACA,IAAIG,OAAO,KAAKT,OAAhB,EAAyB;MACrB,IAAIU,IAAI,GAAGD,OAAX;MACAN,IAAI,CAACC,IAAL,CAAUM,IAAI,CAACC,QAAf;;MACA,OAAMD,IAAI,CAACC,QAAX,EAAoB;QAChBR,IAAI,CAACC,IAAL,CAAUM,IAAI,CAACC,QAAf;QACAD,IAAI,GAAGA,IAAI,CAACC,QAAZ;MACH;;MACDC,OAAO,CAACC,GAAR,CAAYV,IAAZ;MACA,OAAOA,IAAP;MACAS,OAAO,CAACC,GAAR,CAAY,mBAAZ;IACH;;IAEDZ,OAAO,GAAGA,OAAO,CAACa,MAAR,CAAgBC,GAAD,IAASA,GAAG,KAAKN,OAAhC,CAAV;IACAP,SAAS,CAACE,IAAV,CAAeK,OAAf;IAEA,IAAIO,SAAS,GAAGP,OAAO,CAACO,SAAxB;;IACA,KAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGS,SAAS,CAACX,MAA9B,EAAsCE,CAAC,EAAvC,EAA2C;MACvC,IAAIU,QAAQ,GAAGD,SAAS,CAACT,CAAD,CAAxB;;MACA,IAAI,CAACL,SAAS,CAACgB,QAAV,CAAmBD,QAAnB,CAAL,EAAmC;QAC/B,IAAIE,KAAK,GAAGV,OAAO,CAACW,CAAR,GAAY,CAAxB;QACA,IAAIC,OAAO,GAAG,KAAd;;QACA,IAAIpB,OAAO,CAACiB,QAAR,CAAiBD,QAAjB,CAAJ,EAAgC;UAC5B,IAAIE,KAAK,GAAGF,QAAQ,CAACG,CAArB,EAAwB;YACpBH,QAAQ,CAACG,CAAT,GAAaD,KAAb;YACAE,OAAO,GAAG,IAAV;UACH;QACJ,CALD,MAKO;UACHJ,QAAQ,CAACG,CAAT,GAAaD,KAAb;UACAE,OAAO,GAAG,IAAV;UACApB,OAAO,CAACG,IAAR,CAAaa,QAAb;QACH;;QAED,IAAII,OAAJ,EAAa;UACTJ,QAAQ,CAACK,CAAT,GAAaC,SAAS,CAACN,QAAD,EAAWjB,OAAX,CAAtB;UACAiB,QAAQ,CAACT,CAAT,GAAaS,QAAQ,CAACK,CAAT,GAAaL,QAAQ,CAACG,CAAnC;UACAH,QAAQ,CAACN,QAAT,GAAoBF,OAApB;QAEH;MACJ;IACJ;EACJ;AACJ;;KAzDQX,K;;AA2DT,SAASyB,SAAT,CAAmBC,CAAnB,EAAsBC,CAAtB,EAAyB;EACrB,IAAIC,CAAC,GAAGC,IAAI,CAACC,GAAL,CAASJ,CAAC,CAACK,CAAF,GAAML,CAAC,CAACM,CAAjB,IAAsBH,IAAI,CAACC,GAAL,CAASH,CAAC,CAACI,CAAF,GAAMJ,CAAC,CAACK,CAAjB,CAA9B;EACA,OAAOJ,CAAP;AACH;;AAED,eAAe5B,KAAf"},"metadata":{},"sourceType":"module"}